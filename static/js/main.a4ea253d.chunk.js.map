{"version":3,"sources":["index.js"],"names":["CANVAS_SIZE","RECT_WIDTH","RECT_HEIGHT","CIRCLE_RADIUS","RETRY_LIMIT","BoundingRectangle","x","y","width","height","toString","this","br","RandomShapeFiller","props","rectCalculateBoundingRectangle","rotation","rad","Math","PI","sine","sin","cosine","cos","semiCircleCalculateBoundingRectangle","checkCollision","current","i","state","boundingRectangles","length","hasIntersection","handleClick","setState","newShape","boundingRect","shapeAdded","newShapes","shapes","newBoundingRectangles","random","getRandomColor","isOffCanvas","j","concat","window","alert","location","reload","bind","document","title","Konva","Util","fillColor","fill","outerRadius","angle","w","h","stroke","shapeComponents","push","getRectangle","getSemiCircle","className","onClick","React","Component","ReactDOM","render","getElementById"],"mappings":"yRAOMA,EAAc,IACdC,EAAa,GACbC,EAAc,IACdC,EAAgB,GAChBC,EAAc,IAEdC,E,WACF,WAAYC,EAAGC,EAAGC,EAAOC,GAAS,IAAD,gCAQjCC,SAAW,WAAQ,MAAO,MAAQ,EAAKJ,EAAI,QAAU,EAAKC,EAAI,YAAc,EAAKC,MAAQ,aAAe,EAAKC,QANzGE,KAAKL,EAAIA,EACTK,KAAKJ,EAAIA,EACTI,KAAKH,MAAQA,EACbG,KAAKF,OAASA,E,0DAMd,OAAQE,KAAKL,EAAI,GAAKK,KAAKJ,EAAI,GAC3BI,KAAKJ,EAAII,KAAKF,OAAST,GACvBW,KAAKL,EAAIK,KAAKH,MAAQR,I,sCAGdY,GAEZ,OAAIA,EAAGN,IAAMK,KAAKL,GAAKM,EAAGL,IAAMI,KAAKJ,GAAKK,EAAGJ,QAAUG,KAAKH,OAASI,EAAGH,SAAWE,KAAKF,WAG/EG,EAAGN,EAAIK,KAAKL,EAAIK,KAAKH,OAC9BI,EAAGN,EAAIM,EAAGJ,MAAQG,KAAKL,GACvBM,EAAGL,EAAII,KAAKJ,EAAII,KAAKF,QACrBG,EAAGL,EAAIK,EAAGH,OAASE,KAAKJ,O,KAI1BM,E,YACF,WAAYC,GAAQ,IAAD,8BACf,4CAAMA,KAcVC,+BAAiC,SAACT,EAAGC,EAAGS,GACpC,IAAMC,EAAMD,EAAWE,KAAKC,GAAK,IAC3BC,EAAOF,KAAKG,IAAIJ,GAChBK,EAASJ,KAAKK,IAAIN,GACxB,OAAID,GAAY,GACL,IAAIX,EAAkBC,EAAEc,EAAKlB,EAAaK,EAAGa,EAAKlB,EAAYoB,EAAOrB,EAAYqB,EAAOpB,EAAYkB,EAAKnB,GAE7G,IAAII,EAAkBC,EAAEc,EAAKlB,EAAYoB,EAAOrB,EAAYM,EAAEe,EAAOpB,EAAakB,EAAKlB,EAAYoB,EAAOrB,GAAaqB,EAAOpB,EAAYkB,EAAKnB,IAtBvI,EAyBnBuB,qCAAuC,SAAClB,EAAGC,EAAGS,GAC1C,IAAMC,EAAMD,EAAWE,KAAKC,GAAK,IAC3BC,EAAOF,KAAKG,IAAIJ,GAChBK,EAASJ,KAAKK,IAAIN,GAExB,OAAID,GAAY,GACL,IAAIX,EAAkBC,EAAEH,EAAeI,EAAEa,EAAKjB,EAAeA,EAAcmB,EAAOnB,EAAeA,EAAciB,EAAKjB,GACpHa,GAAY,IACZ,IAAIX,EAAkBC,EAAEH,EAAeI,EAAEJ,EAAeA,EAAcmB,EAAOnB,EAAeA,EAAciB,EAAKjB,GAC/Ga,GAAY,IACZ,IAAIX,EAAkBC,EAAEgB,EAAOnB,EAAeI,EAAEJ,EAAeA,EAAcmB,EAAOnB,EAAeA,EAAciB,EAAKjB,GAE1H,IAAIE,EAAkBC,EAAEgB,EAAOnB,EAAeI,EAAEa,EAAKjB,EAAeA,EAAcmB,EAAOnB,EAAeA,EAAciB,EAAKjB,IArCnH,EAwCnBsB,eAAiB,SAACC,GACd,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAKC,MAAMC,mBAAmBC,OAAQH,IACtD,GAAID,EAAQK,gBAAgB,EAAKH,MAAMC,mBAAmBF,IACtD,OAAO,EAGf,OAAO,GA9CQ,EAiDnBK,YAAc,WACV,EAAKC,UAAS,SAAAL,GACV,IAGIM,EAAUC,EAHVC,GAAa,EACbC,EAAYT,EAAMU,OAClBC,EAAwBX,EAAMC,mBAElC,GAAID,EAAMU,OAAOR,OAAS,IAAM,GAC5B,IAAK,IAAIH,EAAI,EAAGA,EAAIvB,EAAauB,IAG7B,GAFAO,EAAW,CAAChB,KAAKsB,UAAUxC,EAAYC,GAAaiB,KAAKsB,UAAUxC,EAAYE,GAA4B,IAAdgB,KAAKsB,SAAc,EAAKC,oBACrHN,EAAe,EAAKpB,+BAA+BmB,EAAS,GAAIA,EAAS,GAAIA,EAAS,KACrEQ,gBAAiB,EAAKjB,eAAeU,GAAtD,CAGIC,GAAa,EACb,YAIR,IAAK,IAAIO,EAAI,EAAGA,EAAIvC,EAAauC,IAG7B,GAFAT,EAAW,CAAC/B,EAAce,KAAKsB,UAAUxC,EAAYG,GAAgBA,EAAce,KAAKsB,UAAUxC,EAA0B,EAAdG,GAAgC,IAAde,KAAKsB,SAAc,EAAKC,oBACxJN,EAAe,EAAKX,qCAAqCU,EAAS,GAAIA,EAAS,GAAIA,EAAS,KAC3EQ,gBAAiB,EAAKjB,eAAeU,GAAtD,CAGIC,GAAa,EACb,MAYZ,OAPIA,GACAC,EAAYT,EAAMU,OAAOM,OAAOV,GAChCK,EAAwBX,EAAMC,mBAAmBe,OAAOT,KAExDU,OAAOC,MAAM,eACbD,OAAOE,SAASC,UAEb,CACHV,OAAQD,EACRR,mBAAoBU,OArF5B,EAAKX,MAAQ,CACTU,OAAS,GACTT,mBAAqB,IAGzB,EAAKG,YAAc,EAAKA,YAAYiB,KAAjB,gBARJ,E,kFAYfC,SAASC,MAAQ,e,uCAkFjB,OAAOC,IAAMC,KAAKZ,mB,mCAGTnC,EAAGC,EAAGS,EAAUsC,GACzB,OAAQ,kBAAC,OAAD,CACAhD,EAAGA,EACHC,EAAGA,EACHC,MAAOP,EACPQ,OAAQP,EACRqD,KAAMD,EACNtC,SAAUA,M,oCAKRV,EAAGC,EAAGS,EAAUsC,GAC1B,OAAQ,kBAAC,MAAD,CACJhD,EAAGA,EACHC,EAAGA,EACHiD,YAAarD,EACboD,KAAMD,EACNG,MAAO,IACPzC,SAAUA,M,4CAIIV,EAAGC,EAAGmD,EAAGC,GAC3B,OAAQ,kBAAC,OAAD,CAAMrD,EAAGA,EAAGC,EAAGA,EAAGC,MAAOkD,EAAGjD,OAAQkD,EAAGC,OAAQ,Y,+BAOvD,IAHA,IAAMC,EAAkB,GAGflC,EAAI,EAAGA,EAAIhB,KAAKiB,MAAMU,OAAOR,OAAQH,GAAG,EACzCA,EAAI,IAAM,EACVkC,EAAgBC,KAAKnD,KAAKoD,aAAapD,KAAKiB,MAAMU,OAAOX,EAAE,GAAIhB,KAAKiB,MAAMU,OAAOX,EAAE,GAAIhB,KAAKiB,MAAMU,OAAOX,EAAE,GAAIhB,KAAKiB,MAAMU,OAAOX,EAAE,KAEnIkC,EAAgBC,KAAKnD,KAAKqD,cAAcrD,KAAKiB,MAAMU,OAAOX,EAAE,GAAIhB,KAAKiB,MAAMU,OAAOX,EAAE,GAAIhB,KAAKiB,MAAMU,OAAOX,EAAE,GAAIhB,KAAKiB,MAAMU,OAAOX,EAAE,KAS5I,OACI,yBAAKsC,UAAU,YACX,kBAAC,QAAD,CAAOzD,MAAOR,EAAaS,OAAQT,EAAakE,QAASvD,KAAKqB,aAC1D,kBAAC,QAAD,KACI,kBAAC,OAAD,CAAM1B,EAAG,EAAGC,EAAG,EAAGC,MAAOR,EAAaS,OAAQT,EAAa4D,OAAQ,UAClEC,S,GAnJOM,IAAMC,WA2JtCC,IAASC,OAAO,kBAACzD,EAAD,MAAuBqC,SAASqB,eAAe,U","file":"static/js/main.a4ea253d.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport Konva from 'konva';\nimport { Stage, Layer, Rect, Arc } from 'react-konva';\n\nconst CANVAS_SIZE = 300;\nconst RECT_WIDTH = 20;\nconst RECT_HEIGHT = 100;\nconst CIRCLE_RADIUS = 50;\nconst RETRY_LIMIT = 500;\n\nclass BoundingRectangle {\n    constructor(x, y, width, height) {\n        // this.id = i;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    toString = () => { return 'x: ' + this.x + ', y: ' + this.y + ', width: ' + this.width + ', height: ' + this.height };\n\n    isOffCanvas() {\n        return (this.x < 0 || this.y < 0 ||\n            this.y + this.height > CANVAS_SIZE ||\n            this.x + this.width > CANVAS_SIZE);\n    }\n\n    hasIntersection(br){\n        // if (br.getID() === this.i) { return false; };\n        if (br.x === this.x && br.y === this.y && br.width === this.width && br.height === this.height) {\n            return false;\n        }\n        return !(br.x > this.x + this.width ||\n        br.x + br.width < this.x ||\n        br.y > this.y + this.height ||\n        br.y + br.height < this.y)\n    };\n}\n\nclass RandomShapeFiller extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            shapes : [],\n            boundingRectangles : []\n        };\n\n        this.handleClick = this.handleClick.bind(this);\n    }\n\n    componentWillMount() {\n        document.title = 'Art or Not';\n    }\n\n    rectCalculateBoundingRectangle = (x, y, rotation) => {\n        const rad = rotation * Math.PI / 180;\n        const sine = Math.sin(rad);\n        const cosine = Math.cos(rad);\n        if (rotation <= 90) {\n            return new BoundingRectangle(x-sine*RECT_HEIGHT, y, sine*RECT_HEIGHT+cosine*RECT_WIDTH, cosine*RECT_HEIGHT+sine*RECT_WIDTH);\n        }\n        return new BoundingRectangle(x-sine*RECT_HEIGHT+cosine*RECT_WIDTH, y+cosine*RECT_HEIGHT, sine*RECT_HEIGHT-cosine*RECT_WIDTH, -cosine*RECT_HEIGHT+sine*RECT_WIDTH);\n    };\n\n    semiCircleCalculateBoundingRectangle = (x, y, rotation) => {\n        const rad = rotation * Math.PI / 180;\n        const sine = Math.sin(rad);\n        const cosine = Math.cos(rad);\n\n        if (rotation <= 90) {\n            return new BoundingRectangle(x-CIRCLE_RADIUS, y-sine*CIRCLE_RADIUS, CIRCLE_RADIUS+cosine*CIRCLE_RADIUS, CIRCLE_RADIUS+sine*CIRCLE_RADIUS);\n        } else if (rotation <= 180) {\n            return new BoundingRectangle(x-CIRCLE_RADIUS, y-CIRCLE_RADIUS, CIRCLE_RADIUS-cosine*CIRCLE_RADIUS, CIRCLE_RADIUS+sine*CIRCLE_RADIUS);\n        } else if (rotation <= 270) {\n            return new BoundingRectangle(x+cosine*CIRCLE_RADIUS, y-CIRCLE_RADIUS, CIRCLE_RADIUS-cosine*CIRCLE_RADIUS, CIRCLE_RADIUS-sine*CIRCLE_RADIUS);\n        }\n        return new BoundingRectangle(x-cosine*CIRCLE_RADIUS, y+sine*CIRCLE_RADIUS, CIRCLE_RADIUS+cosine*CIRCLE_RADIUS, CIRCLE_RADIUS-sine*CIRCLE_RADIUS);\n    };\n\n    checkCollision = (current) => {\n        for (let i = 0; i < this.state.boundingRectangles.length; i++) {\n            if (current.hasIntersection(this.state.boundingRectangles[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    handleClick = () => {\n        this.setState(state => {\n            let shapeAdded = false;\n            let newShapes = state.shapes;\n            let newBoundingRectangles = state.boundingRectangles;\n            let newShape, boundingRect;\n            if (state.shapes.length % 8 === 0) {\n                for (let i = 0; i < RETRY_LIMIT; i++) {\n                    newShape = [Math.random()*(CANVAS_SIZE-RECT_WIDTH), Math.random()*(CANVAS_SIZE-RECT_HEIGHT), Math.random()*180, this.getRandomColor()];\n                    boundingRect = this.rectCalculateBoundingRectangle(newShape[0], newShape[1], newShape[2]);\n                    if (boundingRect.isOffCanvas() || this.checkCollision(boundingRect)) {\n                        continue;\n                    } else {\n                        shapeAdded = true;\n                        break;\n                    }\n                }\n            } else {\n                for (let j = 0; j < RETRY_LIMIT; j++) {\n                    newShape = [CIRCLE_RADIUS+Math.random()*(CANVAS_SIZE-CIRCLE_RADIUS), CIRCLE_RADIUS+Math.random()*(CANVAS_SIZE-CIRCLE_RADIUS*2), Math.random()*360, this.getRandomColor()];\n                    boundingRect = this.semiCircleCalculateBoundingRectangle(newShape[0], newShape[1], newShape[2]);\n                    if (boundingRect.isOffCanvas() || this.checkCollision(boundingRect)) {\n                        continue;\n                    } else {\n                        shapeAdded = true;\n                        break;\n                    }\n                }\n\n            }\n            if (shapeAdded) {\n                newShapes = state.shapes.concat(newShape);\n                newBoundingRectangles = state.boundingRectangles.concat(boundingRect);\n            } else {\n                window.alert(\"Canvas Full\");\n                window.location.reload();\n            }\n            return {\n                shapes: newShapes,\n                boundingRectangles: newBoundingRectangles,\n            };\n        });\n    };\n\n    getRandomColor() {\n        return Konva.Util.getRandomColor();\n    };\n\n    getRectangle(x, y, rotation, fillColor) {\n        return (<Rect\n                x={x}\n                y={y}\n                width={RECT_WIDTH}\n                height={RECT_HEIGHT}\n                fill={fillColor}\n                rotation={rotation}\n            />\n            );\n    };\n\n    getSemiCircle(x, y, rotation, fillColor) {\n        return (<Arc\n            x={x}\n            y={y}\n            outerRadius={CIRCLE_RADIUS}\n            fill={fillColor}\n            angle={180}\n            rotation={rotation}\n        />);\n    };\n\n    getBoundingRectangles(x, y, w, h) {\n        return (<Rect x={x} y={y} width={w} height={h} stroke={\"green\"}/>);\n    };\n\n    render() {\n        const shapeComponents = [];\n        // const boundingRectangles = [];\n\n        for (let i = 0; i < this.state.shapes.length; i+=4) {\n            if (i % 8 === 0) {\n                shapeComponents.push(this.getRectangle(this.state.shapes[i+0], this.state.shapes[i+1], this.state.shapes[i+2], this.state.shapes[i+3]));\n            } else {\n                shapeComponents.push(this.getSemiCircle(this.state.shapes[i+0], this.state.shapes[i+1], this.state.shapes[i+2], this.state.shapes[i+3]));\n            }\n        }\n\n        // for (let j = 0; j < this.state.boundingRectangles.length; j++) {\n        //     const br = this.state.boundingRectangles[j];\n        //     boundingRectangles.push(this.getBoundingRectangles(br.x, br.y, br.width, br.height));\n        // }\n\n        return (\n            <div className=\"centered\">\n                <Stage width={CANVAS_SIZE} height={CANVAS_SIZE} onClick={this.handleClick}>\n                    <Layer>\n                        <Rect x={0} y={0} width={CANVAS_SIZE} height={CANVAS_SIZE} stroke={\"black\"}/>\n                        {shapeComponents}\n                    </Layer>\n                </Stage>\n            </div>\n        )\n    }\n}\n\nReactDOM.render(<RandomShapeFiller />, document.getElementById('root'));\n"],"sourceRoot":""}